{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 92,
   "id": "80be212a",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "from matplotlib import pyplot as plt\n",
    "from sklearn import datasets\n",
    "from sklearn.metrics import mean_squared_error\n",
    "from sklearn.linear_model import LinearRegression\n",
    "from sklearn.linear_model import Ridge\n",
    "from sklearn.linear_model import Lasso\n",
    "from sklearn.linear_model import ElasticNet\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.model_selection import cross_val_score\n",
    "from sklearn.model_selection import GridSearchCV\n",
    "from sklearn.model_selection import KFold\n",
    "from sklearn.datasets import load_iris"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4a89829f",
   "metadata": {},
   "source": [
    "# Gradient Descent, Normalize and Cross Validation Function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 115,
   "id": "c526b256",
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_loss(x, y, coef):\n",
    "    n = len(x)\n",
    "    predictions = x.dot(coef)\n",
    "    errors= np.subtract(predictions, y)\n",
    "    sqrErrors = np.square(errors)\n",
    "    J = 1/ (2 * n) * errors.T.dot(errors)\n",
    "    \n",
    "    return J\n",
    "\n",
    "\n",
    "def gradient_descent(x, y, coefs, max_interations=1000, alpha=1):\n",
    "    n = len(x)\n",
    "    cost_history = np.zeros(max_interations)\n",
    "    for i in range(max_interations):\n",
    "        predictions = x.dot(coefs)\n",
    "        #print('predictions: ', predictions[:5])\n",
    "        errors= np.subtract(predictions, y)\n",
    "        #print('errors= ', errors[:5])\n",
    "        sum_delta = (alpha/n)*x.transpose().dot(errors);\n",
    "        #print('sum_delta= ', sum_delta[:5])\n",
    "        coefs = coefs - sum_delta;\n",
    "        cost_history[i] = get_loss(x, y, coefs)\n",
    "        \n",
    "    return coefs, cost_history\n",
    "\n",
    "def get_cv_scores(model):\n",
    "    scores = cross_val_score(model,\n",
    "                             X__train,\n",
    "                             y__train,\n",
    "                             cv=5,\n",
    "                             scoring='r2')\n",
    "    \n",
    "    print('CVs: ', scores)\n",
    "    print('CV Mean (R2): ', np.mean(scores))\n",
    "    print('STD (Desvio Padrão): ', np.std(scores))\n",
    "    print('\\n')\n",
    "    \n",
    "    \n",
    "def normalize(X_norm, Y_norm):\n",
    "    for column in X_norm.columns:\n",
    "        X_norm[column] = (X_norm[column] - X_norm[column].min())/(X_norm[column].max() - X_norm[column].min())\n",
    "    for column in Y_norm:\n",
    "        Y_norm = (Y_norm - Y_norm.min())/(Y_norm.max() - Y_norm.min())\n",
    "    return X_norm, Y_norm\n",
    "   "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "39d9c0f6",
   "metadata": {},
   "source": [
    "# Load DataSet"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 101,
   "id": "9317207b",
   "metadata": {},
   "outputs": [],
   "source": [
    "iris = load_iris()\n",
    "\n",
    "df = pd.DataFrame(data=iris.data, columns=iris.feature_names)\n",
    "\n",
    "df[\"target\"] = iris.target\n",
    "\n",
    "X = df.iloc[:, :-1]\n",
    "Y = df.iloc[:, 4]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 102,
   "id": "2815b272",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "     sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)\n",
      "0                  5.1               3.5                1.4               0.2\n",
      "1                  4.9               3.0                1.4               0.2\n",
      "2                  4.7               3.2                1.3               0.2\n",
      "3                  4.6               3.1                1.5               0.2\n",
      "4                  5.0               3.6                1.4               0.2\n",
      "..                 ...               ...                ...               ...\n",
      "145                6.7               3.0                5.2               2.3\n",
      "146                6.3               2.5                5.0               1.9\n",
      "147                6.5               3.0                5.2               2.0\n",
      "148                6.2               3.4                5.4               2.3\n",
      "149                5.9               3.0                5.1               1.8\n",
      "\n",
      "[150 rows x 4 columns]\n"
     ]
    }
   ],
   "source": [
    "print(X)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4c56d004",
   "metadata": {},
   "source": [
    "# Normalizing DataSet"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 103,
   "id": "e8a504f0",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/var/folders/88/knx7zw015qbbjy6wrxv2zrsc0000gn/T/ipykernel_79505/3139021213.py:41: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  X_norm[column] = (X_norm[column] - X_norm[column].min())/(X_norm[column].max() - X_norm[column].min())\n"
     ]
    }
   ],
   "source": [
    "X,y = normalize(X, Y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 104,
   "id": "c284a47f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "     sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)\n",
      "0             0.222222          0.625000           0.067797          0.041667\n",
      "1             0.166667          0.416667           0.067797          0.041667\n",
      "2             0.111111          0.500000           0.050847          0.041667\n",
      "3             0.083333          0.458333           0.084746          0.041667\n",
      "4             0.194444          0.666667           0.067797          0.041667\n",
      "..                 ...               ...                ...               ...\n",
      "145           0.666667          0.416667           0.711864          0.916667\n",
      "146           0.555556          0.208333           0.677966          0.750000\n",
      "147           0.611111          0.416667           0.711864          0.791667\n",
      "148           0.527778          0.583333           0.745763          0.916667\n",
      "149           0.444444          0.416667           0.694915          0.708333\n",
      "\n",
      "[150 rows x 4 columns]\n"
     ]
    }
   ],
   "source": [
    "print(X)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8cb8e79e",
   "metadata": {},
   "source": [
    "# Spliting DataSet"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 105,
   "id": "f976865c",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Train and test split for k-fold crossvalidation\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=27)\n",
    "\n",
    "#Train(80%), Test(10%) and Validation(10%)\n",
    "X__train, X__rem, y__train, y__rem = train_test_split(X,y, train_size=0.8)\n",
    "\n",
    "X__valid, X__test, y__valid, y__test = train_test_split(X__rem,y__rem, test_size=0.5)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c3cd02ee",
   "metadata": {},
   "source": [
    "# Linear Regression"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 106,
   "id": "1887788e",
   "metadata": {},
   "outputs": [],
   "source": [
    "reg=LinearRegression()\n",
    "reg=LinearRegression().fit(X__train,y__train)\n",
    "lr_coef = reg.coef_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 107,
   "id": "0ed6789f",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([-0.24717935, -0.04098046,  0.80597335,  0.63558877])"
      ]
     },
     "execution_count": 107,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "lr_coef"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a20eaa03",
   "metadata": {},
   "source": [
    "# Gradient Descent"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 116,
   "id": "643ecda8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "First 5 values from cost_history = [0.00594869 0.00593348 0.00592282 0.00591428 0.00590745]\n",
      "Last 5 values from cost_history = [0.00586595 0.00586595 0.00586595 0.00586595 0.00586595]\n"
     ]
    }
   ],
   "source": [
    "coeficients, cost_history = gradient_descent(X__train, y__train, lr_coef)\n",
    "print('First 5 values from cost_history =', cost_history[:5])\n",
    "print('Last 5 values from cost_history =', cost_history[-5 :])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d21f8484",
   "metadata": {},
   "source": [
    "# Displaying Cost Function in gradient descent operation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 117,
   "id": "c1f401af",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Text(0.5, 1.0, 'Convergence of gradient descent. alpha=0.01')"
      ]
     },
     "execution_count": 117,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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2WV53XHjYN994eCD4aCD8rTjjjk8SpKkNRn01FWae/yOOy6XLVyY7+y99to8ff7z8KlP5WVTpuQbPRrhb9as3BMoSZIMetoAbLVVvlv3jW/M35cvz8O9jeB37bVwxRWr7uLdfnvYf/881Lv//nnaaqv66i9JUl0Metrg9PfnIdx994UTTshlTz0FN9wAv/oV/PrXcOONcOmlq7aZPn318LfffjBzpjd7SJJ6m0FPPWHTTeE1r8lTw5IlcPPNOfTdeGMOgN///qoHN0+aBHvuCXvvDXvtlT8XLx5bzwFIklQBg5561iab5Lt1DzlkVdnvfw9z5+bQd+utef7SS/N1f9nLmTZt9fC31145EE6aVMdRSJK0/gx6GlU23hhe+tI8NaSUH+o8dy5861vzeOaZnbn1VjjvPHj66VXrbbNNfu3b7rvDbrutmp8xwzt/JUndyaCnUS8CXvSiPI0dO5/Zs3cGYOVKuO++HABvuw3uugvuvBMuuigPCzdMnLh68GsEwZ12ysskSaqLQU8awpgxOazttBO87nWrylOCRx7Joa8x3XUX/Pznqx723PCiF+Xtd955zU8fAyNJqppBT1pHEflxLVttBa961erLnn4afvObHPzuuSdP8+blV75ddNHq62622erhb6edYIcd8uNhttkmPyBakqQXwqAnddCECase/dLq6afzUPC8eauHwBtugEsuWXU3MOQwOWNGDn3bb58fBdOYb0zjx4/QQUmSNlgGPWmETJiQ797dc881lz3/PDz4IDzwANx/f/5szF9zDXz966sHQYBp01aFwG23zb2AM2as+tx6axjr02IkaVQz6EldYOzYVcO3g1m+HB5+ePUA2Ji/6Sb4znfgmWdW3yYiPyi6Ofw1fzbmvWFEknqXQU/aAPT3w3bb5enQQ9dcnhI88QQsWADz56/5ec898JOf5HVaTZ6crzds3Hk81DR1KvT1VX+skqTOMehJPSAi38W7xRb5Ic9DefrpNUPgwoX5LuJHHskPkl64cPXHxzSMGZPDXmsonD49l0+dClOmrJrfeOPqjleS1B6DnjSKTJgAu+ySp+EsW5YfIt0IgINNt92WP59/fvB9TJq0evAbLAw2f5882QdPS1KnGfQkrWHiRNhxxzwNpzFk/Pjj8Nhjq0/NZY88kh88/dhj+TV0g+nvX9Urufnmq88vXrw9c+euuWyL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\n",
      "text/plain": [
       "<Figure size 720x432 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(range(1, 1000 +1), cost_history, color ='blue')\n",
    "plt.rcParams[\"figure.figsize\"] = (10,6)\n",
    "plt.grid()\n",
    "plt.xlabel(\"Number of iterations\")\n",
    "plt.ylabel(\"cost (J)\")\n",
    "plt.title(\"Convergence of gradient descent. alpha=0.01\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a80dde6c",
   "metadata": {},
   "source": [
    "# Great coeficients from Gradient Descent"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 155,
   "id": "921c7d64",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "sepal length (cm)   -0.212105\n",
       "sepal width (cm)    -0.104009\n",
       "petal length (cm)    0.723787\n",
       "petal width (cm)     0.666219\n",
       "dtype: float64"
      ]
     },
     "execution_count": 155,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "coeficients"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 119,
   "id": "d902c906",
   "metadata": {},
   "outputs": [],
   "source": [
    "reg=LinearRegression()\n",
    "reg=LinearRegression().fit(X__train,y__train)\n",
    "reg.coef_ = coeficients"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c88dd7a0",
   "metadata": {},
   "source": [
    "# Ridge Regression"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 142,
   "id": "d1967873",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "GridSearchCV(cv=5, estimator=Ridge(),\n",
       "             param_grid={'alpha': [1e-15, 1e-10, 1e-08, 0.001, 0.01, 1, 5, 10,\n",
       "                                   20, 30, 35, 40, 45, 50, 55, 100, 200, 300,\n",
       "                                   500, 1000]},\n",
       "             scoring='neg_mean_squared_error')"
      ]
     },
     "execution_count": 142,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ridge = Ridge()\n",
    "parameter={'alpha':[1e-15, 1e-10, 1e-8, 1e-3, 1e-2, 1, 5, 10, 20, 30, 35, 40, 45, 50, 55, 100, 200, 300, 500, 1000]}\n",
    "ridge_regressor=GridSearchCV(ridge, parameter, scoring='neg_mean_squared_error', cv=5)\n",
    "ridge_regressor.fit(X__valid, y__valid)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 143,
   "id": "92b87c20",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The best alpha value:\n",
      "{'alpha': 0.01}\n",
      "The best score from that alpha:\n",
      "-0.015403971200428301\n"
     ]
    }
   ],
   "source": [
    "print(\"The best alpha value:\")\n",
    "print(ridge_regressor.best_params_)\n",
    "print(\"The best score from that alpha:\")\n",
    "print(ridge_regressor.best_score_)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3e449a08",
   "metadata": {},
   "source": [
    "# Ridge Regression with best alpha in train dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 144,
   "id": "8418a23c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CVs:  [0.86605548 0.94470116 0.94136721 0.93904368 0.93041185]\n",
      "CV Mean (R2):  0.9243158770409867\n",
      "STD (Desvio Padrão):  0.029511525718990066\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "ridge = Ridge(alpha=0.01).fit(X__train, y__train)\n",
    "get_cv_scores(ridge)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e4d1c31d",
   "metadata": {},
   "source": [
    "# Lasso Regression"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 145,
   "id": "b832e0f7",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "GridSearchCV(cv=5, estimator=Lasso(),\n",
       "             param_grid={'alpha': [1e-15, 1e-10, 1e-08, 0.001, 0.01, 0.1, 0.5,\n",
       "                                   1, 5, 10, 20, 30, 35, 40, 45, 50, 55, 100,\n",
       "                                   200, 300, 500, 1000]},\n",
       "             scoring='neg_mean_squared_error')"
      ]
     },
     "execution_count": 145,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "lasso=Lasso()\n",
    "parameter={'alpha':[1e-15, 1e-10, 1e-8, 1e-3, 1e-2,0.1, 0.5, 1, 5, 10, 20, 30, 35, 40, 45, 50, 55, 100, 200, 300, 500, 1000]}\n",
    "lasso_regressor=GridSearchCV(lasso, parameter, scoring='neg_mean_squared_error', cv=5)\n",
    "lasso_regressor.fit(X__valid,y__valid)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 146,
   "id": "bc571e8a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The best alpha value:\n",
      "{'alpha': 0.001}\n",
      "The best score from that alpha:\n",
      "-0.012981603372471107\n"
     ]
    }
   ],
   "source": [
    "print(\"The best alpha value:\")\n",
    "print(lasso_regressor.best_params_)\n",
    "print(\"The best score from that alpha:\")\n",
    "print(lasso_regressor.best_score_)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b540498a",
   "metadata": {},
   "source": [
    "# Lasso Regression with best alpha in train dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 147,
   "id": "b70cacb5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CVs:  [0.86788047 0.94436553 0.93662125 0.93800232 0.92713297]\n",
      "CV Mean (R2):  0.922800508619226\n",
      "STD (Desvio Padrão):  0.02800763766954912\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "lasso = Lasso(alpha=0.001).fit(X__train, y__train)\n",
    "get_cv_scores(lasso)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c097d7bc",
   "metadata": {},
   "source": [
    "# ElasticNet Regression"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 148,
   "id": "37a91c1d",
   "metadata": {},
   "outputs": [],
   "source": [
    "en=ElasticNet()\n",
    "parameter={'alpha':[1e-15, 1e-10, 1e-8, 1e-3, 1e-2,0.1, 0.5, 1, 5, 10, 20, 30, 35, 40, 45, 50, 55, 100, 200, 300, 500, 1000]}\n",
    "en_regressor=GridSearchCV(lasso, parameter, scoring='neg_mean_squared_error', cv=5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 149,
   "id": "110b6c19",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Melhor Alpha:\n",
      "{'alpha': 0.001}\n",
      "Melhor score:\n",
      "-0.012981603372471107\n"
     ]
    }
   ],
   "source": [
    "en_regressor.fit(X__valid,y__valid)\n",
    "print(\"Best Alpha:\")\n",
    "print(en_regressor.best_params_)\n",
    "print(\"Best score:\")\n",
    "print(en_regressor.best_score_)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "424b193e",
   "metadata": {},
   "source": [
    "# ElasticNet Regression with best alpha in train dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 150,
   "id": "6e0838c4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CVs:  [0.86788047 0.94436553 0.93662125 0.93800232 0.92713297]\n",
      "CV Mean (R2):  0.922800508619226\n",
      "STD (Desvio Padrão):  0.02800763766954912\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "en = ElasticNet(alpha=0.001).fit(X__train, y__train)\n",
    "get_cv_scores(lasso)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fcbcfb0b",
   "metadata": {},
   "source": [
    "# Regressions Comparison"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 151,
   "id": "42c0ceee",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Linear Regression CVs\n",
      "CVs:  [0.86576214 0.94460848 0.94149763 0.93895828 0.93051683]\n",
      "CV Mean (R2):  0.9242686724669795\n",
      "STD (Desvio Padrão):  0.02962560742451923\n",
      "\n",
      "\n",
      "Ridge CVs\n",
      "{'alpha': 0.01}\n",
      "CVs:  [0.86605548 0.94470116 0.94136721 0.93904368 0.93041185]\n",
      "CV Mean (R2):  0.9243158770409867\n",
      "STD (Desvio Padrão):  0.029511525718990066\n",
      "\n",
      "\n",
      "Lasso CVs\n",
      "{'alpha': 0.001}\n",
      "CVs:  [0.86788047 0.94436553 0.93662125 0.93800232 0.92713297]\n",
      "CV Mean (R2):  0.922800508619226\n",
      "STD (Desvio Padrão):  0.02800763766954912\n",
      "\n",
      "\n",
      "ElasticNet CVs\n",
      "{'alpha': 0.001}\n",
      "CVs:  [0.86788047 0.94436553 0.93662125 0.93800232 0.92713297]\n",
      "CV Mean (R2):  0.922800508619226\n",
      "STD (Desvio Padrão):  0.02800763766954912\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "print('Linear Regression CVs')\n",
    "get_cv_scores(reg)\n",
    "print('Ridge CVs')\n",
    "print(ridge_regressor.best_params_)\n",
    "get_cv_scores(ridge)\n",
    "print('Lasso CVs')\n",
    "print(lasso_regressor.best_params_)\n",
    "get_cv_scores(lasso)\n",
    "print('ElasticNet CVs')\n",
    "print(en_regressor.best_params_)\n",
    "get_cv_scores(lasso)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "382720a0",
   "metadata": {},
   "source": [
    "# Applying each trained and otimized regression in the test dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 152,
   "id": "0ff1725b",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9235761413120858"
      ]
     },
     "execution_count": 152,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ridge.score(X__test, y__test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 153,
   "id": "16d92bd2",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9234862565038686"
      ]
     },
     "execution_count": 153,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "lasso.score(X__test, y__test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 154,
   "id": "a88be36d",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9238770339188027"
      ]
     },
     "execution_count": 154,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "en.score(X__test, y__test)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3dbe8171",
   "metadata": {},
   "source": [
    "# Exercício 2: Validação Cruzada"
   ]
  },
  {
   "cell_type": "raw",
   "id": "92d7b738",
   "metadata": {},
   "source": [
    "• Explain in your own words how Cross-Validation works.\n",
    "• Explain in what contexts should we use it? Why?"
   ]
  },
  {
   "cell_type": "raw",
   "id": "f9b95692",
   "metadata": {},
   "source": [
    "Cross-validation consists of randomly dividing a dataset into subsets, categorizing each set for a different function. Usually divided into three parts, the subsets created are:\n",
    "\n",
    "Training Subset\n",
    " - used to train the model, and obtain the optimized coefficients\n",
    "Validation Subset\n",
    " - used to validate the model, and get the optimized alpha value\n",
    "Test Subset\n",
    " - used to test model accuracy\n",
    "\n",
    "The proportions of the subsets vary, but normally the training subset takes about 70% of the data, basically the largest portion, and the rest, about 30% to 20%, is split evenly between the validation and testing subsets.\n",
    "It is important to have a minimum of data available for each subset, if the dataset is too small and suffers a penalty in accuracy for few numbers in the subsets, the best alternative is to apply another cross-validation process, called K-fold.\n",
    "\n",
    "K-fold is a method that divides the dataset into some subgroups with equal amounts, and there is a relay of functions between them, so that from several scenarios, different results of the interactions between the subgroups, we can have a better estimate of the functioning and model accuracy, even with little data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1b94311d",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
